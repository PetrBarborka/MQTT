<!DOCTYPE html>
<html>

  <head>
    <link rel="stylesheet" href="style.css">
    <script src="script.js"></script>
  </head>

<body>

<ul class="menu">
  <li class="limenu"><a href="#2min">2min</a></li>
  <li class="limenu"><a href="#basics">Basics</a></li>
  <li class="limenu"><a href="#packets">Packets</a></li>
  <li class="limenu"><a href="#topics">Topics</a></li>
  <li class="limenu"><a href="#qos">QoS</a></li>
  <li class="limenu"><a href="#robustness">Robustness</a></li>
  <li class="limenu"><a href="#security">Security</a></li>
  <li class="limenu"><a href="#sources">Sources</a></li>
  <li class="limenu"><a href="implementation.html">Implementation</a></li>
</ul>

<div class="article">
    <div class="anchor" id="2min">
      <img class="banner" src="img/wasp_banner.png" alt="macro of a wasp">
      <h1>MQTT in 2 minutes</h1>
      <div id="loader-connect" style="width=20%">
        <br>
        <img class="banner" src="svg/overview.svg" alt="MQTT overview of MQTT network">
        <br>
        <br>
      </div>
      MQTT is an open source network communication protocol that aims to be
      lightweight, low overhead and robust against weak and unstable connections.
      It follows the publish/subscribe design pattern with Clients connecting
      and subscribing to a Broker which directs the message flow. 
      It runs on TCP/IP networks using its own architecture of MQTT packets.
      <br><br>
      
      Here is what it looks like at different application levels:
      <br><br>
      <table>
        <tr>
          <th>Hardware</th>
          <td>Computer</td>
          <td>Computer</td>
        </tr>
        <tr>
          <th>Software</th>
          <td>Client</td>
          <td>Broker</td>
        </tr>
        <tr>
          <th>Role</th>
          <td>Publisher/Subscriber</td>
          <td>Broker</td>
        </tr>
      </table>
      <br style="clear:left"><br>
      As the protocol is open-source, there is many commercial and free 
      implementations of both clients and brokers with different design 
      philosophies. The implementation may for example provide advanced security
      features like TLS, gateways outside of TCP/IP networks or might be
      especially suited for embedded systems.
      <br><br>
      For more information keep on reading and check out the <a href="index.html#sources">sources section</a>
    </div>
    <div class="anchor" id="basics">
      <h1>The Basic principle</h1>
      <h2>The Network</h2>
      MQTT runs on a network consisting of one or more computers
      connected in a <span class="hi">TCP/IP</span> network
      <h2>The Software</h2>
      Two kinds of programs are running on the network: at least one
      <span class="hi">Broker</span> and at least two 
      <span class="hi">Clients</span> are needed for meaningful operation.
      <br> The Clients publish information to the Broker and the Broker sends
      them any information that concerns them. They communicate
      via TCP/IP packets.
      <h2>Operation</h2>
      The client <span class="hi">connects</span> to a Broker.
      <br>The client
      <span class="hi">subscribes</span> to one or more
      <span class="hi">Topics</span>. 
      <br>The client <span class="hi">publishes</span> a message to one of the 
      Themes. The Broker forwards that message to any Client connected to it and
      subscribed to that Theme.
    </div>
    <div class="anchor" id="packets">
      <H1>Packets and processes</H1>
      This section describes the different processes that take place
      in the MQTT network along with packets that are used.
      <h2>Connection</h2>
      Once a Client establishes a TCP/IP connection to a Broker, it is required
      to send a CONNECT packet in a specified timeframe. The CONNECT packet must contain its clientID, information about whether it wishes to continue previously started session and may or may not contain authentification data (username, pwd), the last will, its QoS and ping interval to be used for the keep-alive procedure (in seconds). Once the CONNECT packet is received by the Broker, the Broker must always respond with a CONNACK packet starting whether previous session data is available and a return code for the connection stating whether the connection was accepted or why not (see standard).
    <div id="loader-connect">
      <br>
      <img src="svg/connection.svg" alt="MQTT connection procedure">
      <br>
      <br>
    </div>
      <table>
        <tr>
          <th>CONNECT</th><th></th>
        </tr>
        <tr>
          <th>attribute</th><th>example</th>
        </tr>
        <tr>
          <th>client Id</th><td>"client01"</td>
        </tr>
        <tr>
          <th>cleanSession</th><td>false</td>
        </tr>
        <tr>
          <th>userName</th><td>"user1"</td>
        </tr>
        <tr>
          <th>password</th><td>"pwd"</td>
        </tr>
        <tr>
          <th>LastWillTopic</th><td>"client01/will"</td>
        </tr>
        <tr>
          <th>LastWillQoS</th><td>2</td>
        </tr>
        <tr>
          <th>LastWillMessage</th><td>"client01died"</td>
        </tr>
        <tr>
          <th>keepAlive</th><td>60</td>
        </tr>
      </table>
      <table>
        <tr>
          <th>CONNACK</th><th></th>
        </tr>
        <tr>
          <th>attribute</th><th>example</th>
        </tr>
        <tr>
          <th>sessionPresent</th><td>false</td>
        </tr>
        <tr>
          <th>returnCode</th><td>0</td>
        </tr>
      </table>
      <br style="clear:left">
      To terminate the connection gracefully, the Client has to let the Broker know it's disconnecting willingly and not as a result of some kind of error. That is what the
      DISCONNECT packet is for. It requires no response. Upon graceful disconnection, the Will message of the Client will be removed from the Broker unsent.
      <table>
        <tr>
          <th>DISCONNECT</th><th></th>
        </tr>
        <tr>
          <th>attribute</th><th>example</th>
        </tr>
        <tr>
          <th>-</th><td>-</td>
        </tr>
      </table>
      <br style="clear:left">
    </div>
      <br>
      <h2>Subscription</h2>
      In order to receive messages from other clients, our client first needs to subscribe to a Topic. Topics are a great feature helping MQTT communication stay clear and well managed, see dedicated section. The subscription process is initiated with a SUBSCRIBE packet, that only contains a packetId for verification, a list of topics it wishes to subscribe to and a list of maximum Quality of service levels it wishes for that Topic. This value is a ceiling, so if our client specifies QoS 1 when subscribing to topic "a" and someone sends a message with QoS 2 on that topic, it gets handed to our client with QoS 1. The mandatory response is a SUBACK packet with return codes for each Topic. The standard permits, but doesn't require a procedure authorizing individual clients for individual topics. Some Broker providers, such as HiveMQ, provide such procedures using TLS certificates etc.
      <div id="loader-subscribe">
        <br>
        <img src="svg/subscription.svg" alt="MQTT connection procedure">
        <br>
        <br>
      </div>
      <div>
        <table> 
        <tr>
          <th>SUBSCRIBE</th><th></th>
        </tr>
        <tr>
          <th>attribute</th><th>example</th>
        </tr>
        <tr>
          <th>packetId</th><td>33333</td>
        </tr>
        <tr>
          <th>QoS1</th><td>2</td>
        </tr>
        <tr>
          <th>Topic1</th><td>"client5/temperature"</td>
        </tr>
        <tr>
          <th>QoS2</th><td>1</td>
        </tr>
        <tr>
          <th>Topic2</th><td>"client5/humidity"</td>
        </tr>
        <tr>
          <th>...</th><td>...</td>
        </tr>
      </table>
      <table> 
        <tr>
          <th>SUBACK</th><th></th>
        </tr>
        <tr>
          <th>attribute</th><th>example</th>
        </tr>
        <tr>
          <th>packetId</th><td>33333</td>
        </tr>
        <tr>
          <th>returnCode1</th><td>0</td>
        </tr>
        <tr>
          <th>returnCode2</th><td>0</td>
        </tr>
        <tr>
          <th>...</th><td>...</td>
        </tr>
      </table>
      <br style="clear:left">
      <h2>Unsubscription</h2>
      The unsubscription process is analoguous to the subscription procedure.
      <div id="loader-unsubscribe">
        <br>
        <img src="svg/unsubscription.svg" alt="MQTT connection procedure">
        <br>
        <br>
      </div>
      <table>
        <tr>
          <th>UNSUBSCRIBE</th><th></th>
        </tr>
        <tr>
          <th>attribute</th><th>example</th>
        </tr>
        <tr>
          <th>packetId</th><td>33334</td>
        </tr>
        <tr>
          <th>Topic1</th><td>"client5/temperature"</td>
        </tr>
        <tr>
          <th>Topic2</th><td>"client5/humidity"</td>
        </tr>
        <tr>
          <th>...</th><td>...</td>
        </tr>
      </table>
      <table>
        <tr>
          <th>UNSUBACK</th><th></th>
        </tr>
        <tr>
          <th>attribute</th><th>example</th>
        </tr>
        <tr>
          <th>packetId</th><td>33333</td>
        </tr>
        <tr>
          <th>returnCode1</th><td>0</td>
        </tr>
        <tr>
          <th>returnCode2</th><td>0</td>
        </tr>
        <tr>
          <th>...</th><td>...</td>
        </tr>
      </table>
      <br style="clear:left">
      <h2>Publishing</h2>
      Message transmission in a MQTT network is called publishing. Client C publishes a message on topic T to the Broker and every other Client connected to that Broker and subscribed to Topic T message gets the message. The PUBLISH packet contains an ID, Topic specification, maximum QoS level, a retain flag which states whether the message should be kept as a last valid value for that topic, the message itself or "payload" and a flag that specifies whether this is the original message or a resend attempt. <br>
      Publishing procedure varies greatly with QoS: 
      <ul>
        <li>QoS 0 means the message is sent once and the sender doesn't care about its fate. </li>
        <li>Qos 1 means the message is resent any number of
          times before the recipient confirms reception</li>
        <li>QoS 2 means both the sender and the receiver double
          check whether the message was received exactly once </li>
      </ul>
      This process works both ways: The Client publishes a message
      to the Broker and the Broker sends the same message through the same process to the concerned Clients.
      <div id="loader-publish">
        <h3>Quality of service 0 - at most once<h3>
        <br>
        <img src="svg/publishing_qos0.svg" alt="MQTT connection procedure">
        <br>
        <br>
        <h3>Quality of service 1 - at least once<h3>
        <br>
        <img src="svg/publishing.svg" alt="MQTT connection procedure">
        <br>
        <br>
        <h3>Quality of service 2 - exactly once<h3>
        <br>
        <img src="svg/publishing_qos2.svg" alt="MQTT connection procedure">
        <br>
        <br>
      </div>
        <table>
          <tr>
            <th>PUBLISH</th><th></th>
          </tr>
          <tr>
            <th>attribute</th><th>example</th>
          </tr>
          <tr>
            <th>packetId</th><td>33335</td>
          </tr>
          <tr>
            <th>topicName</th><td>"client5/temperature"</td>
          </tr>
          <tr>
            <th>QoS</th><td>1</td>
          </tr>
          <tr>
            <th>retainFlag</th><td>1</td>
          </tr>
          <tr>
            <th>payload</th> <td>"the humidity is 50%"</td>
          </tr>
          <tr>
            <th>dupFlag</th> <td>false</td>
          </tr>
        </table>
        <table>
          <tr>
            <th>PUBACK</th><th></th>
          </tr>
          <tr>
            <th>packetId</th><td>33335</td>
          </tr>
        </table>
        <table>
          <tr>
            <th>PUBREC</th><th></th>
          </tr>
          <tr>
            <th>packetId</th><td>33335</td>
          </tr>
        </table>
        <table>
          <tr>
            <th>PUBREL</th><th></th>
          </tr>
          <tr>
            <th>packetId</th><td>33335</td>
          </tr>
        </table>
        <table>
          <tr>
            <th>PUBCOMP</th><th></th>
          </tr>
          <tr>
            <th>packetId</th><td>33335</td>
          </tr>
        </table>
        <br style="clear:left">
      <h2>Keep-alive</h2>
      The keep-alive procedure serves to check whether the client is still available after a longer period of inactivity. The Client specifies the keep-alive interval in seconds in the CONNECT packet (with the ability to disable the procedure entirely) and then if the Broker has not received any packets from the Client for that specified ammount of time, it sends a PINGREQ packet expecting a PINGRESP response. The packets have no contents.
      <div id="loader-keepalive">
        <br>
        <img src="svg/keep-alive.svg" alt="MQTT connection procedure">
        <br>
        <br>
      </div>
      <table>
          <tr>
            <th>PINGREQ</th><th></th>
          </tr>
          <tr>
            <th>-</th><td>-</td>
          </tr>
        </table>
        <table>
          <tr>
            <th>PINGRESP</th><th></th>
          </tr>
          <tr>
            <th>-</th><td>-</td>
          </tr>
        </table>
        <br style="clear:left">
    </div>
    <div class="anchor" id="topics">
      <H1>Topics</H1>
      Topics is are an important, perhaps defining feature of MQTT. A Topic is defined for each published message and the other clients only get that message if they have previosly subscribed to that Topic. 
      <br><br>
      They are defined as a string and MQTT recognizes a path hierarchy divided by a slash as in "root/child/grandchild". There are also two wildcard characters that can be put anywhere in the Topic string: "+" is a single level wildcard, while "#" is a multilevel wildcard matching any path downstream. For example: 
      <br><br>
      <table>
        <tr> <th>path</th><th>matches/doesn't match</th><th></th> </tr>
        <tr> <th> house/+/temperature </th><td class=yes> house/kitchen/temperature </td> <td class=no> house/kitchen/fridge/temperature </td> </tr>
        <tr> <th> house/#/temperature </th> <td class=yes> house/kitchen/temperature </td> <td class=yes> house/kitchen/fridge/temperature </td> </tr>
      </table>
      <br style="clear:left;">
      <br><br>
      While the wildcards techicaly permit to listen to the "#" Topic, meaning they get any message that goes through the Broker, it is greatly discouraged even for debugging purposes (which are beter served via debugging applications). Quite the opposite: it is encouraged to create as many Topics and Topic levels as possible delivering every message only to clients that have to have it.
      <br><br>
      There are no hard guidelines to naming Topics with one exception: the Topics beginning with "$" are so called system topics. They are used by the Broker to publish system information and the Clients are not allowed to publish in them. They are not exactly defined in the standard and their contents rely on the Broker implementation. One example would be the <a href="https://github.com/mqtt/mqtt.github.io/wiki/SYS-Topics">HiveMQ implemenation</a>, that includes for example:

      <ul>
        <li style="float:none;">$SYS/broker/clients/connected</li>
        <li>$SYS/broker/clients/disconnected</li>
        <li>$SYS/broker/clients/total</li>
        <li>$SYS/broker/messages/sent</li>
        <li>$SYS/broker/uptime</li>
      </ul>
      <br style="clear:left">

      A freshly connected Client won't receive any messages at all. The Topics are created ad hoc on the first mention - no separate definition needed.
    </div>
    <div class="anchor" id="qos">
      <H1>Quality of Service</H1>
      MQTT Quality of Service is a mechanism that allows Clients to trade network traffic volume and performance load for reliability of service. It comes in three levels: 0, 1 and 2. The desired QoS is specified with each PUBLISH package and that level is used to send the message to the Broker. That same level is used to send the message Broker->Client, unless the Client has specified lower maximum QoS for that theme when subscribing to it.<br> Short version: we have a QoS level specified in SUBSCRIBE and another one in PUBLISH. The lower number is used.
      <br><br>
      The different Quality of Service levels were already described in the section dedicated to the PUBLISH packet. Once more:
      <ul>
        <li><span class=hi>QoS 0, or "at most once"</span> means the message is sent once and the sender doesn't care about its fate. </li>
        <li><span class=hi>Qos 1, or "at least once"</span> means the message is resent any number of
          times before the recipient confirms reception</li>
        <li><span class=hi>QoS 2, or "exactly once"</span> means both the sender and the receiver double
          check whether the message was received exactly once </li>
      </ul>
    </div>
    <div class="anchor" id="robustness">
      <H1>Queuing and robustness</H1>
      MQTT employs three other mechanisms to compensate for unreliable networks:
      <h2>Last will</h2>
      Upon connection, the Client is allowed, but not required to specify a message and a Topic to use when the Broker finds the Client unresponsive, meaning the Client probably disconnected ungracefully without sending the DISCONNECT packet, so the Broker can let everyone concerned know that the disconnected Client is no longer listening.
      <h2>Persistent session</h2>
      If a Persistent session is enabled for a Clients connection, the Broker will remember all of its subscriptions and queue all its messages until it comes back. Upon reconnection, the Client specifies again whether it wants to continue the persistent session and it can also delete the stored data with a cleanSession flag. If it wishes to continue, the Broker lets it know whether there is a previous session to continue with the sessionPresent flag of the CONNACK package. 
      <h2>Retained messages</h2>
      Since the period between messages can get very long in MQTT, a newly subscribed Client can wait for a long time before it gets a first message on that Topic. Because of that situation, publishing client can mark any message as "retained" indicating that the Broker should store its contents as a "last good value". That way, when a new subscriber comes to a Topic, it gets this message without anyone publishing anything. 
    </div>
    <div class="anchor" id="security">
      <H1>Security</H1>
      By default, the MQTT standard only includes rules for authentification of clients using username and password transmitted in plain text form. It defines mechanisms for refusing connection or access to specific Topic, but doesn't specify how should the authentification and authorization take place. 
      <br>
      This leaves security mostly up to implementation with some Client/Broker providers specializing in this field such as HiveMQ that provides means of authentification and authorization with TLS certificates on sides of both Client and Broker as well as a plugin interface for writing custom validation functions that serve as event handlers for specific situation (connecting, subscribing, publishing etc.). Deploying a secure network is definitely worth considering.
    </div>
    <div class="anchor" id="sources">
      <H1>Sources</H1>
      This report mostly consists of information gathered from HiveMQ series <a href="http://www.hivemq.com/mqtt-essentials/">MQTT essentials</a> and <a href="http://www.hivemq.com/mqtt-security-fundamentals/">MQTT security fundamentals</a>. Those provide the basics in quite digestable and easy to read form. The definitive guide on MQTT is of course the <a href="http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718111">standard itself</a>.
      See also the <a href="https://github.com/mqtt/mqtt.github.io/wiki">MQTT comunity wiki</a> on github
    </div>
<!--     <div id="implementation">
      <H1>Implementation</H1>
    </div> -->
  </div> <!-- class="article" -->
  </body>

</html>





















